<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>아치 리눅스 탐험기 | wanja's blog</title><meta name=keywords content="Arch Linux,CLI,OS,UTM(VM)"><meta name=description content="아치 리눅스(Arch Linux)를 직접 설치하면서 겪었던 과정과 다양한 시행착오, 그리고 느낀 점들을 공유합니다. CLI 환경에서 시스템을 구축하는 나름의 여정을 담았습니다."><meta name=author content="wanja"><link rel=canonical href=https://wan0514.github.io/posts/arch_linux/><link crossorigin=anonymous href=/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css integrity="sha256-j+ECM6cGvIfy4Is8+XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as=style><link rel=icon href=https://wan0514.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://wan0514.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://wan0514.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://wan0514.github.io/apple-touch-icon.png><link rel=mask-icon href=https://wan0514.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://wan0514.github.io/posts/arch_linux/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://wan0514.github.io/posts/arch_linux/"><meta property="og:site_name" content="wanja's blog"><meta property="og:title" content="아치 리눅스 탐험기"><meta property="og:description" content="아치 리눅스(Arch Linux)를 직접 설치하면서 겪었던 과정과 다양한 시행착오, 그리고 느낀 점들을 공유합니다. CLI 환경에서 시스템을 구축하는 나름의 여정을 담았습니다."><meta property="og:locale" content="ko"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-07-13T02:00:00+09:00"><meta property="article:modified_time" content="2025-07-13T02:00:00+09:00"><meta property="article:tag" content="Arch Linux"><meta property="article:tag" content="CLI"><meta property="article:tag" content="OS"><meta property="article:tag" content="UTM(VM)"><meta name=twitter:card content="summary"><meta name=twitter:title content="아치 리눅스 탐험기"><meta name=twitter:description content="아치 리눅스(Arch Linux)를 직접 설치하면서 겪었던 과정과 다양한 시행착오, 그리고 느낀 점들을 공유합니다. CLI 환경에서 시스템을 구축하는 나름의 여정을 담았습니다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://wan0514.github.io/posts/"},{"@type":"ListItem","position":2,"name":"아치 리눅스 탐험기","item":"https://wan0514.github.io/posts/arch_linux/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"아치 리눅스 탐험기","name":"아치 리눅스 탐험기","description":"아치 리눅스(Arch Linux)를 직접 설치하면서 겪었던 과정과 다양한 시행착오, 그리고 느낀 점들을 공유합니다. CLI 환경에서 시스템을 구축하는 나름의 여정을 담았습니다.","keywords":["Arch Linux","CLI","OS","UTM(VM)"],"articleBody":"🚀 왜 아치 리눅스를 설치하게 되었을까요? 저는 운영체제 잘 모르는 비전공자였습니다. CS 공부의 중요성을 알면서도 다른 개발 공부를 하느라 늘 미루고 있었죠. 그러다 운영체제에 대해 공부하기 시작하면서 리눅스를 직접 설치해보고 싶다는 생각이 들었습니다. 마냥 읽는 것보다는 직접 운영체제를 설치하고 내부 동작을 이해하는 것이 좋다는 것을 이전에 ‘FAT32의 구조를 직접 구현’ 하면서 파일 시스템에 대해 공부가 많이 되었기 때문입니다.\n앞서 말씀드렸던 것처럼, 저는 운영체제를 전혀 모르고 설치해본 적도 없습니다. 따라서 직접 제 컴퓨터에 운영체제를 설치하는 것은 너무 위험하다고 판단했습니다.\n그래서 가상 머신(VM) 을 이용하기로 했습니다.\n가상 머신도 처음 사용해보지만… 요즘은 많은 서비스가 등장했고, 그리 어렵지 않으니까요! 인공지능 덕분에 무언가를 학습하고 활용하는 것은 정말 쉬워진 것 같습니다 :)\n그렇게 저는 아치 리눅스(Arch Linux) 에 도전했습니다. 쉬운 길 대신 직접 ‘맨땅에 헤딩’하면서 시스템의 심장부를 파고들어 보고 싶었거든요. 이 글은 단순히 아치 리눅스 설치 가이드가 아닙니다. 제가 겪었던 삽질과 그 과정에서 얻은 운영체제와 하드웨어에 대한 깨달음을 공유하는 기록입니다.\n🤯 나는 왜 x86_64.iso 파일을 쓸 수 없는 걸까? (ft.cpu 아키텍처) 아치 리눅스를 설치하기 위해서 가장 먼저 할 일은 설치를 위한 부팅 파일인 iso 파일을 다운로드하는 것입니다. 공식 사이트 다운로드 페이지로 가면 x86_64.iso 파일이 있습니다. iso 파일에 대해서 먼저 공부하다 보니, cpu 아키텍처에 대해서 알게 되었고, 제 컴퓨터의 cpu를 그대로 사용하는 가상화 기술을 사용하기 위해서는, 해당 아키텍처를 지원하는 부팅 파일이 필요했습니다.\n제가 사용하는 맥북은 M1 Pro 칩셋, 즉 ARM 아키텍처 CPU를 사용합니다. 공식 사이트에서 제공하는 x86_64.iso 파일은 제 로컬 환경이 윈도우나 Intel 기반일 경우에나 쓸 수 있는 파일이었습니다.\n“그럼 내 맥북은 뭘 써야 하는 거지?”\n검색해보니 ARM이 지원되는 파일을 찾아야 하고, 그 파일은 .tar.gz 형식으로 얻을 수 있다고 하더군요. 문제는 이 .tar.gz 파일이 그냥 압축된 ‘설치 후 구성 파일’ 덩어리라서, 이걸로 설치하려면 복잡한 과정이 필요하다는 사실이었습니다. 여기에는 부트로더도 없고 임시 리눅스 환경도 없어서, 다른 방법으로 부팅 가능한 환경(우분투, 데몬 등)을 만들어준 다음 이 파일을 풀어 넣고, ARM에 맞는 부트로더를 수동으로 설치해야 했습니다.\n“부트 로더는 뭐고…임시 리눅스 환경은 왜 필요한 것이며… 설치 파일을 그냥 설치하면 안되는 것인가…?”\n솔직히 처음에는 이 과정을 이해하지 못했습니다.(지금은 이해하나, 당시 리눅스도 모르는 제 수준에서는 저 과정을 이해하게 힘들었습니다.)\n그래서 저는 ARM을 지원하는 iso파일이 존재하지 않을까…? 더 쉬운 방법이 있지 않을까…? 에뮬레이션을 사용하면 되지만, 가능한 파일이 존재하지 않을까하는 마음에 먼저 더 찾아보기 시작했습니다.\n그렇게 찾은 것이 Arch Boot였습니다. 당시에는 드디어 ARM이 지원되는 iso 파일을 찾았다는 기쁨에… 이걸 냅다 가상화를 시켜서 구동해봤습니다. 그런데 이 또한 자동으로 설치되는 파일이더군요. 즉, 파티션을 나누고, 파일 시스템을 포맷하고, 부트로더를 설치하는 등(이후 글에 등장할 내용)의 과정을 Enter를 치면서 선택하는, 좀 더 쉽게 아치 리눅스를 설치하는 방식이었습니다. 내부 과정을 추상화해서 쉽게 사용하는 파일이었습니다.\n그래도 일단 이 파일을 부팅용으로 사용하고, 자동화를 빠져나온 후 설치를 제가 직접 하는 방식을 시도해 보았습니다. 하지만 과정 중에 기본 명령어인 vim이나 nano가 없는 것을 보고 ‘아, 필요한 파일이 존재하지 않는구나. 내가 직접 설치를 못 하는 건가…?’ 하는 생각에 결국 포기했습니다. 나중에 알고 보니, 에뮬레이터로 x86_64.iso 파일을 사용해도 똑같이 vim이나 nano가 기본적으로 설치되어 있지 않더군요. 여기서 또 제가 파일을 잘못 다운로드받은 줄 알고 다른 파일도 찾아보고 재설치도 많이 했으나, 그냥 원래 없는 것이었습니다…ㅋㅋ\n이 모든 삽질 끝에 일단은 에뮬레이션이라는 방법을 써서 x86_64.iso 파일을 사용하기로 했습니다. 제가 선택한 UTM(가상 머신)은 에뮬레이션 기능을 제공합니다. 이 기능은 호스트(제 맥북)와 게스트(아치 리눅스)의 CPU 아키텍처가 다를 때 명령어들을 번역해서 실행해주는 기능이며, 성능 저하가 발생할 수 있다는 단점이 있지만 학습 목표는 이룰 수 있기 때문에 중요하지 않다고 판단했습니다.\nHTTP Direct Downloads에서 한국 미러 서버를 통해 archlinux-2025.07.01-x86_64.iso 파일을 다운로드했습니다. 그리고 UTM을 설치하고 새로운 가상 환경을 만들었죠. 드라이브에 이 iso 파일을 넣고, 부팅을 시작했습니다.\n이 삽질을 통해 저는 다음을 깨달았습니다.\nCPU 아키텍처의 중요성: 컴퓨터 전공자라면 기본일 이 개념을, 저는 이제야 몸으로 배웠습니다. x86, ARM, RISC-V 등 CPU 설계 방식이 다르다는 것, 그리고 각 아키텍처에 맞는 운영체제 파일이 따로 존재한다는 것을요. .iso vs .tar.gz: 단순히 ‘압축 파일’인 줄 알았던 이 두 가지 형식의 차이가 이렇게 클 줄이야…(애초에 저런 파일 형식도 처음 봤답니다. 하하..) .iso 파일은 부팅 가능한 CD/DVD 복사본처럼, OS 설치를 위한 부트로더와 임시 라이브 리눅스 환경을 모두 포함한다는 것. .tar.gz 파일은 이미 설치된 OS의 ‘내용물’일 뿐, 부트로더나 설치 환경이 없다는 것. 따라서 이걸로 OS를 설치하려면 훨씬 복잡하고 수동적인 과정이 필요하다. 가상화와 에뮬레이션: 호스트와 게스트의 CPU 아키텍처가 같을 때(‘가상화’)는 성능이 좋지만, 다를 때(‘에뮬레이션’)는 성능 저하가 있더라도 일단 구동은 가능하다는 것을요. 제 맥북에서 x86_64 아치 리눅스를 돌리기 위해 에뮬레이션이라는 개념을 이해해야 했습니다. Arch Linux는 최소한만 제공한다: 아치 리눅스가 ‘Minimal’하다고 말하는 의미를 깨달았습니다. 정말 아무것도 없는, 사용자가 필요한 모든 것을 직접 설치하고 구축해야 하는 OS라는 것을요. 이는 운영체제의 핵심 요소가 무엇인지 역으로 생각하게 만들었습니다. 환경에 대한 가정의 위험성: 제가 윈도우나 다른 리눅스 배포판에서 당연하게 생각했던 ‘기본 설치’라는 것이 아치 리눅스에서는 통용되지 않는다는 것을 알게 됐습니다. 모든 OS가 동일한 기본 구성을 가지고 있지 않다는 중요한 교훈을 얻었습니다. 커뮤니티의 중요성: 혼자서 해결할 수 없는 문제는 결국 커뮤니티의 도움을 받아야 한다는 것을 다시 한번 느꼈습니다. 그리고 그 과정에서 다른 사람들도 비슷한 경험을 한다는 것에 안도감도 느꼈죠. 설치 파일 하나 고르는데 이렇게 많은 CS 개념이 필요할 줄이야… 솔직히 이 과정만으로도 참 많은 공부가 되었습니다…\n🤯 부팅 과정과 파티션의 의미 (ft. fdisk) 에뮬레이션을 이용하여 아치 리눅스 x86_64.iso 파일을 UTM(가상 머신)에 넣고 부팅했습니다. 옆에는 공식 사이트의 설치 가이드 화면을 띄워두고, 다른 화면에는 제 학습을 도와줄 Gemini를 띄워두었죠. 아래는 부팅에 성공하면 뜨는 터미널 화면입니다.\n마주한 첫 난관은 파티션 설정. 공식 문서의 fdisk라는 명령어를 보고 ‘이게 뭐야…?’ 싶었습니다. 솔직히 말하면, 파티션 나누는 단계를 애매하게 이해한 채 진행하다가 꼬여서, 파티션을 초기화하고 재설정하는 것을 많이 반복했습니다…(여러분은 공식 문서와 인공지능을 활용해서 충분히 이해하고 하시기를…)\n그래도 이 ‘삽질’ 덕분에 iso 파일과 파티션의 의미를 알게 됐습니다. iso 파일은 그냥 설치 파일 덩어리가 아니라, 운영체제를 컴퓨터에 설치하기 위한 부팅 가능한 ‘시동 디스크’ 복사본이고, 그 안에는 OS를 실행시킬 부트로더와 설치 환경이 통째로 들어있다는 걸 알았습니다.\n그리고 파티션! 왜 하드디스크를 굳이 EFI, Swap, Root 등으로 쪼개야 하는지 궁금했는데, 관련 명령어들을 공부하고 각 과정의 이유를 찾아보니 비로소 그 필요성을 깨달았습니다. 특히, 이는 효율적인 메모리 관리를 포함한 시스템 자원 활용과 밀접한 관련이 있다는 것을 알게 되었습니다. 아래처럼 파티션을 확인할 수 있습니다.\nEFI 파티션 (FAT32) 비유하자면 ‘운영체제를 깨우는 알람 시계’ 같은 곳입니다. 컴퓨터가 켜지면 제일 먼저 이곳을 찾아 부팅에 필요한 파일을 읽습니다. 이 파티션을 FAT32 파일 시스템으로 포맷해야 했는데, 이건 UEFI 펌웨어라는 녀석이 이 형식만 읽을 수 있다고 명시했기 때문이었죠. 마치 통역사가 특정 언어만 알아듣는 것처럼요.\nSwap 파티션 이건 ‘RAM이 지칠 때 잠시 쉬어가는 임시 휴게소’입니다. RAM(메모리)이 부족할 때 하드디스크의 이 공간을 빌려 쓴다는 걸 알았을 때, ‘와, OS가 이렇게 똑똑하게 자원을 관리하는구나!’ 싶었습니다.\n처음에 Swap 파티션이 왜 필요하고, 어떻게 빌려쓰는 것인지 궁금해서 파고 또 파며 공부를 하다 보니, 가상 메모리, 페이징, MMU 학습까지 갔다가 돌아왔습니다. 🫠 덕분에 RAM의 실제 용량보다 더 많은 용량을 사용할 수 있는 시스템에 대해서 알게 되었습니다.(너무 깊게 가긴 했지만…)\nRoot 파티션 (ext4) 이건 운영체제와 모든 파일이 들어가는 ‘내 집’의 가장 큰 방입니다. 리눅스에서는 ext4라는 파일 시스템을 주로 씁니다.\n파티션 과정을 직접 겪으면서, 단순히 용량을 나누는 걸 넘어 데이터 저장 방식, 파일 시스템의 종류, 그리고 디스크 관리의 중요성을 몸으로 체감했습니다.\n🌐 하드웨어에 존재하는 운영체제 파일을 누가 실행시키는 걸까? (펌웨어와 부트로드) 파티션 과정을 넘겼더니 이제 부트로더와 펌웨어라는 녀석들이 등장했습니다. 공식 사이트 가이드에서 grub-install 같은 CLI 명령어를 입력하라고 하는데, 이 역할이 무엇인지부터 학습을 했습니다.\n펌웨어는 하드웨어 장치에 내장된 아주 기본적인 지시사항이자, 하드웨어와 소프트웨어(운영체제)의 다리 역할을 합니다. 마치 ‘하드웨어가 알아듣는 언어로 OS의 명령을 통역해주는 통역사’ 같은 거죠. 컴퓨터 전원을 켜면 가장 먼저 실행되는 것이 메인보드의 UEFI 펌웨어였습니다.\n제가 아치 리눅스 설치할 때 EFI 시스템 파티션에 부트로더를 설치한 것도 바로 이 UEFI 펌웨어가 해당 부트로더를 찾아 실행할 수 있게 하기 위함이었습니다. 그리고 신기하게도 grub-install 명령어가 단순히 GRUB 파일을 복사하는 것을 넘어, UEFI 펌웨어 자체에 “여기 아치 리눅스가 부팅할 파일이 있어!“라고 알려주는 부팅 항목을 등록하는 역할까지 하는 것이죠.\n이 과정을 통해 하드웨어와 소프트웨어의 상호작용은 물론, 펌웨어의 역할, 그리고 시스템 부팅 시퀀스의 복잡성을 직접 경험하며 컴퓨터 시스템 아키텍처에 대한 깊은 이해를 얻게 됐습니다. 머릿속에 들어있던 컴퓨터 부팅 과정이 조금씩 구체화되었습니다.\n🔗 네트워크와 원격 접속 (ft. ssh와 No route to host) 운영체제 설치를 마치고, 제 로컬 맥북에서 가상 머신에 접속하고 싶었습니다. 그러기 위해서는 ssh라는 것을 사용해야 했죠. 분명 GitHub에서 repo를 clone할 때 ssh라는 단어를 봤었는데, ‘그게 그거인가?’ 하는 기억을 가지고 ssh가 무엇인지부터 학습했습니다. ssh는 원격으로 컴퓨터에 접속할 수 있는 프로토콜입니다. 이것을 통해 멀리 있는 컴퓨터에 여러 사람이 접속해서 마치 그 컴퓨터 앞에 앉아 사용하는 것처럼 할 수 있다는 점이 놀라웠습니다.\n학습을 끝내고 가상 머신으로 띄운 제 아치 리눅스 컴퓨터에 로컬 터미널로 접속하기 위해 ssh를 사용해보기로 했습니다.\n하지만 ssh: connect to host 192.168.생략 port 22: No route to host라는 에러가 발생했습니다.\n에러 메시지를 확인해보니 제 맥북이 가상 환경의 SSH 서버에 접근하기 위한 **‘네트워크 상의 길 자체를 찾지 못했다’**는 의미였습니다.\n문제를 해결하기 위해 다음 과정을 차례로 시도해봤습니다.\n가상 머신이 켜져 있는지 확인. 가상 머신에 네트워크 연결이 되어 있는지 확인. 네트워크 IP 주소로 로컬에서 제대로 접속한 것인지 확인. 최후의 수단으로 가상 머신을 아예 재부팅해보기. 1, 2, 3번 과정을 먼저 진행했으나 모두 정상임을 확인했습니다. 결국 최후의 수단인 재부팅을 하니 되는 것이 아니겠습니까…\n알고 보니 재부팅 과정에서 가상 머신의 네트워크 인터페이스가 다시 깨끗하게 초기화되고, IP 주소를 올바르게 재할당받았으며, SSH 서버 데몬도 시스템 시작 시에 정상적으로 다시 실행되었던 겁니다.\n최종적으로 아래처럼 로컬 터미널에서 Arch Linux로 접속에 성공했습니다.\n이 단순한 ‘재부팅 해결’을 통해 네트워크 통신의 기본 원리, IP 주소 및 라우팅 개념, 그리고 운영체제 내에서 서비스 데몬이 어떻게 시작되고 동작하는지를 실전에서 이해하게 되었습니다. 눈에 보이지 않던 ‘네트워크’라는 길이 비로소 눈에 보이는 듯했습니다.\n💡 결론: 삽질을 통한 성장 아치 리눅스 설치는 분명 쉽지 않았습니다. 얼마나 재설치를 많이 했는지… 하지만 이 ‘삽질’들은 제게 단순히 운영체제를 설치하는 방법을 넘어, 운영체제의 부팅 원리, 파일 시스템의 종류와 역할, 하드웨어와 소프트웨어의 상호작용, 그리고 기본적인 네트워크 통신 개념까지 CS의 핵심 기초 지식을 알게 되었습니다. 앞으로 더 많이, 더 깊게 알아야 된다는 것 또한 말이죠… 부지런히 공부해야겠습니다. 다행인 건 이런 공부가 재미있다는 것이 제겐 긍정적입니다.\n비전공자였기에 오히려 더 깊이 파고들 수 있었던 것 같아요. 헤매긴 했으나, 그만큼 쌓이겠거니 생각합니다! 아무튼 아치 리눅스를 설치하면서 아무것도 몰랐던 컴퓨터 시스템을 직접 열어보고, 그 내부에서 어떤 일들이 벌어지는지 조금이나마 엿볼 수 있었던 소중한 경험이었습니다.\n🔗 아치 리눅스 설치 과정 날것 기록 보러 가기: 아치 리눅스 설치 및 학습 과정 노션 메모\n","wordCount":"1582","inLanguage":"en","datePublished":"2025-07-13T02:00:00+09:00","dateModified":"2025-07-13T02:00:00+09:00","author":{"@type":"Person","name":"wanja"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://wan0514.github.io/posts/arch_linux/"},"publisher":{"@type":"Organization","name":"wanja's blog","logo":{"@type":"ImageObject","url":"https://wan0514.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://wan0514.github.io/ accesskey=h title="wanja's blog (Alt + H)">wanja's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">아치 리눅스 탐험기</h1><div class=post-description>아치 리눅스(Arch Linux)를 직접 설치하면서 겪었던 과정과 다양한 시행착오, 그리고 느낀 점들을 공유합니다. CLI 환경에서 시스템을 구축하는 나름의 여정을 담았습니다.</div><div class=post-meta><span title='2025-07-13 02:00:00 +0900 +0900'>July 13, 2025</span>&nbsp;·&nbsp;wanja</div></header><div class=post-content><h2 id=-왜-아치-리눅스를-설치하게-되었을까요>🚀 왜 아치 리눅스를 설치하게 되었을까요?<a hidden class=anchor aria-hidden=true href=#-왜-아치-리눅스를-설치하게-되었을까요>#</a></h2><p>저는 운영체제 잘 모르는 비전공자였습니다.
CS 공부의 중요성을 알면서도 다른 개발 공부를 하느라 늘 미루고 있었죠. 그러다 운영체제에 대해 공부하기 시작하면서 리눅스를 직접 설치해보고 싶다는 생각이 들었습니다. 마냥 읽는 것보다는 직접 운영체제를 설치하고 내부 동작을 이해하는 것이 좋다는 것을 이전에 &lsquo;FAT32의 구조를 직접 구현&rsquo; 하면서 파일 시스템에 대해 공부가 많이 되었기 때문입니다.</p><p>앞서 말씀드렸던 것처럼, 저는 운영체제를 전혀 모르고 설치해본 적도 없습니다. 따라서 직접 제 컴퓨터에 운영체제를 설치하는 것은 너무 위험하다고 판단했습니다.</p><p>그래서 <strong>가상 머신(VM)</strong> 을 이용하기로 했습니다.</p><blockquote><p><em>가상 머신도 처음 사용해보지만&mldr; 요즘은 많은 서비스가 등장했고, 그리 어렵지 않으니까요! 인공지능 덕분에 무언가를 학습하고 활용하는 것은 정말 쉬워진 것 같습니다 :)</em></p></blockquote><p>그렇게 저는 <strong>아치 리눅스(Arch Linux)</strong> 에 도전했습니다. 쉬운 길 대신 직접 &lsquo;맨땅에 헤딩&rsquo;하면서 시스템의 심장부를 파고들어 보고 싶었거든요. 이 글은 단순히 아치 리눅스 설치 가이드가 아닙니다. 제가 겪었던 삽질과 그 과정에서 얻은 운영체제와 하드웨어에 대한 깨달음을 공유하는 기록입니다.</p><hr><h3 id=-나는-왜-x86_64iso-파일을-쓸-수-없는-걸까-ftcpu-아키텍처>🤯 나는 왜 x86_64.iso 파일을 쓸 수 없는 걸까? (ft.cpu 아키텍처)<a hidden class=anchor aria-hidden=true href=#-나는-왜-x86_64iso-파일을-쓸-수-없는-걸까-ftcpu-아키텍처>#</a></h3><p>아치 리눅스를 설치하기 위해서 가장 먼저 할 일은 설치를 위한 부팅 파일인 <code>iso</code> 파일을 다운로드하는 것입니다. 공식 사이트 다운로드 페이지로 가면 <code>x86_64.iso</code> 파일이 있습니다. iso 파일에 대해서 먼저 공부하다 보니, cpu 아키텍처에 대해서 알게 되었고, 제 컴퓨터의 cpu를 그대로 사용하는 <strong>가상화</strong> 기술을 사용하기 위해서는, 해당 아키텍처를 지원하는 부팅 파일이 필요했습니다.</p><p>제가 사용하는 맥북은 M1 Pro 칩셋, 즉 <strong>ARM 아키텍처 CPU</strong>를 사용합니다. 공식 사이트에서 제공하는 <code>x86_64.iso</code> 파일은 제 로컬 환경이 윈도우나 Intel 기반일 경우에나 쓸 수 있는 파일이었습니다.</p><p><em>&ldquo;그럼 내 맥북은 뭘 써야 하는 거지?&rdquo;</em></p><p>검색해보니 ARM이 지원되는 파일을 찾아야 하고, 그 파일은 <code>.tar.gz</code> 형식으로 얻을 수 있다고 하더군요. 문제는 이 <code>.tar.gz</code> 파일이 그냥 압축된 &lsquo;설치 후 구성 파일&rsquo; 덩어리라서, 이걸로 설치하려면 복잡한 과정이 필요하다는 사실이었습니다. 여기에는 부트로더도 없고 임시 리눅스 환경도 없어서, 다른 방법으로 부팅 가능한 환경(우분투, 데몬 등)을 만들어준 다음 이 파일을 풀어 넣고, ARM에 맞는 부트로더를 수동으로 설치해야 했습니다.</p><p><em>&ldquo;부트 로더는 뭐고&mldr;임시 리눅스 환경은 왜 필요한 것이며&mldr; 설치 파일을 그냥 설치하면 안되는 것인가&mldr;?&rdquo;</em></p><p>솔직히 처음에는 이 과정을 이해하지 못했습니다.(지금은 이해하나, 당시 리눅스도 모르는 제 수준에서는 저 과정을 이해하게 힘들었습니다.)</p><p>그래서 저는 ARM을 지원하는 iso파일이 존재하지 않을까&mldr;? 더 쉬운 방법이 있지 않을까&mldr;? 에뮬레이션을 사용하면 되지만, 가능한 파일이 존재하지 않을까하는 마음에 먼저 더 찾아보기 시작했습니다.</p><p>그렇게 찾은 것이 <strong>Arch Boot</strong>였습니다. 당시에는 드디어 ARM이 지원되는 <code>iso</code> 파일을 찾았다는 기쁨에&mldr; 이걸 냅다 가상화를 시켜서 구동해봤습니다. 그런데 이 또한 자동으로 설치되는 파일이더군요. 즉, 파티션을 나누고, 파일 시스템을 포맷하고, 부트로더를 설치하는 등(이후 글에 등장할 내용)의 과정을 <code>Enter</code>를 치면서 선택하는, 좀 더 쉽게 아치 리눅스를 설치하는 방식이었습니다. 내부 과정을 추상화해서 쉽게 사용하는 파일이었습니다.</p><p>그래도 일단 이 파일을 부팅용으로 사용하고, 자동화를 빠져나온 후 설치를 제가 직접 하는 방식을 시도해 보았습니다. 하지만 과정 중에 기본 명령어인 <code>vim</code>이나 <code>nano</code>가 없는 것을 보고 &lsquo;아, 필요한 파일이 존재하지 않는구나. 내가 직접 설치를 못 하는 건가&mldr;?&rsquo; 하는 생각에 결국 포기했습니다. 나중에 알고 보니, 에뮬레이터로 <code>x86_64.iso</code> 파일을 사용해도 똑같이 <code>vim</code>이나 <code>nano</code>가 기본적으로 설치되어 있지 않더군요. 여기서 또 제가 파일을 잘못 다운로드받은 줄 알고 다른 파일도 찾아보고 재설치도 많이 했으나, 그냥 원래 없는 것이었습니다&mldr;ㅋㅋ</p><p>이 모든 삽질 끝에 일단은 <strong>에뮬레이션</strong>이라는 방법을 써서 <code>x86_64.iso</code> 파일을 사용하기로 했습니다. 제가 선택한 UTM(가상 머신)은 에뮬레이션 기능을 제공합니다. 이 기능은 호스트(제 맥북)와 게스트(아치 리눅스)의 CPU 아키텍처가 다를 때 명령어들을 번역해서 실행해주는 기능이며, 성능 저하가 발생할 수 있다는 단점이 있지만 학습 목표는 이룰 수 있기 때문에 중요하지 않다고 판단했습니다.</p><p><strong><img alt="UTM 가상 머신 설정 화면" loading=lazy src=/images/utm-setup.png title="UTM에서 가상 환경을 설정하는 모습"></strong></p><p><a href=https://archlinux.org/download/>HTTP Direct Downloads</a>에서 <a href=https://kr.mirrors.cicku.me/archlinux/iso/2025.07.01/>한국 미러</a> 서버를 통해 <code>archlinux-2025.07.01-x86_64.iso</code> 파일을 다운로드했습니다. 그리고 UTM을 설치하고 새로운 가상 환경을 만들었죠. 드라이브에 이 <code>iso</code> 파일을 넣고, 부팅을 시작했습니다.</p><p><strong>이 삽질을 통해 저는 다음을 깨달았습니다.</strong></p><ul><li><strong>CPU 아키텍처의 중요성</strong>: 컴퓨터 전공자라면 기본일 이 개념을, 저는 이제야 몸으로 배웠습니다. <code>x86</code>, <code>ARM</code>, <code>RISC-V</code> 등 CPU 설계 방식이 다르다는 것, 그리고 각 아키텍처에 맞는 운영체제 파일이 따로 존재한다는 것을요.</li><li><strong><code>.iso</code> vs <code>.tar.gz</code></strong>: 단순히 &lsquo;압축 파일&rsquo;인 줄 알았던 이 두 가지 형식의 차이가 이렇게 클 줄이야&mldr;(애초에 저런 파일 형식도 처음 봤답니다. 하하..)<ul><li><code>.iso</code> 파일은 부팅 가능한 CD/DVD 복사본처럼, OS 설치를 위한 <strong>부트로더</strong>와 임시 <strong>라이브 리눅스 환경</strong>을 모두 포함한다는 것.</li><li><code>.tar.gz</code> 파일은 이미 설치된 OS의 &lsquo;내용물&rsquo;일 뿐, 부트로더나 설치 환경이 없다는 것. 따라서 이걸로 OS를 설치하려면 훨씬 복잡하고 수동적인 과정이 필요하다.</li></ul></li><li><strong>가상화와 에뮬레이션</strong>: 호스트와 게스트의 CPU 아키텍처가 같을 때(&lsquo;가상화&rsquo;)는 성능이 좋지만, 다를 때(&lsquo;에뮬레이션&rsquo;)는 성능 저하가 있더라도 일단 구동은 가능하다는 것을요. 제 맥북에서 <code>x86_64</code> 아치 리눅스를 돌리기 위해 <strong>에뮬레이션</strong>이라는 개념을 이해해야 했습니다.</li><li><strong>Arch Linux는 최소한만 제공한다</strong>: 아치 리눅스가 &lsquo;Minimal&rsquo;하다고 말하는 의미를 깨달았습니다. 정말 아무것도 없는, 사용자가 필요한 모든 것을 직접 설치하고 구축해야 하는 OS라는 것을요. 이는 <strong>운영체제의 핵심 요소</strong>가 무엇인지 역으로 생각하게 만들었습니다.</li><li><strong>환경에 대한 가정의 위험성</strong>: 제가 윈도우나 다른 리눅스 배포판에서 당연하게 생각했던 &lsquo;기본 설치&rsquo;라는 것이 아치 리눅스에서는 통용되지 않는다는 것을 알게 됐습니다. 모든 OS가 동일한 기본 구성을 가지고 있지 않다는 중요한 교훈을 얻었습니다.</li><li><strong>커뮤니티의 중요성</strong>: 혼자서 해결할 수 없는 문제는 결국 커뮤니티의 도움을 받아야 한다는 것을 다시 한번 느꼈습니다. 그리고 그 과정에서 다른 사람들도 비슷한 경험을 한다는 것에 안도감도 느꼈죠.</li></ul><p>설치 파일 하나 고르는데 이렇게 많은 CS 개념이 필요할 줄이야&mldr; 솔직히 이 과정만으로도 참 많은 공부가 되었습니다&mldr;</p><hr><h3 id=-부팅-과정과-파티션의-의미-ft-fdisk>🤯 부팅 과정과 파티션의 의미 (ft. <code>fdisk</code>)<a hidden class=anchor aria-hidden=true href=#-부팅-과정과-파티션의-의미-ft-fdisk>#</a></h3><p>에뮬레이션을 이용하여 아치 리눅스 <code>x86_64.iso</code> 파일을 UTM(가상 머신)에 넣고 부팅했습니다. 옆에는 공식 사이트의 설치 가이드 화면을 띄워두고, 다른 화면에는 제 학습을 도와줄 Gemini를 띄워두었죠. 아래는 부팅에 성공하면 뜨는 터미널 화면입니다.</p><p><strong><img alt="아치 리눅스 설치 초기 프롬프트" loading=lazy src=/images/arch-cli-boot.png title="root@archiso ~# 프롬프트 화면"></strong></p><p>마주한 첫 난관은 파티션 설정. 공식 문서의 <code>fdisk</code>라는 명령어를 보고 &lsquo;이게 뭐야&mldr;?&rsquo; 싶었습니다. 솔직히 말하면, 파티션 나누는 단계를 애매하게 이해한 채 진행하다가 꼬여서, 파티션을 초기화하고 재설정하는 것을 많이 반복했습니다&mldr;(여러분은 공식 문서와 인공지능을 활용해서 충분히 이해하고 하시기를&mldr;)</p><p>그래도 이 &lsquo;삽질&rsquo; 덕분에 <code>iso</code> 파일과 파티션의 의미를 알게 됐습니다. <code>iso</code> 파일은 그냥 설치 파일 덩어리가 아니라, 운영체제를 컴퓨터에 설치하기 위한 부팅 가능한 &lsquo;시동 디스크&rsquo; 복사본이고, 그 안에는 OS를 실행시킬 부트로더와 설치 환경이 통째로 들어있다는 걸 알았습니다.</p><p>그리고 파티션! 왜 하드디스크를 굳이 EFI, Swap, Root 등으로 쪼개야 하는지 궁금했는데, 관련 명령어들을 공부하고 각 과정의 이유를 찾아보니 비로소 그 필요성을 깨달았습니다. 특히, 이는 <strong>효율적인 메모리 관리</strong>를 포함한 시스템 자원 활용과 밀접한 관련이 있다는 것을 알게 되었습니다.
아래처럼 파티션을 확인할 수 있습니다.</p><p><strong><img alt="fdisk 파티션 테이블 화면" loading=lazy src=/images/fdisk-partition-table.png title="fdisk로 파티션을 확인하는 모습"></strong></p><h4 id=efi-파티션-fat32><strong>EFI 파티션 (FAT32)</strong><a hidden class=anchor aria-hidden=true href=#efi-파티션-fat32>#</a></h4><p>비유하자면 &lsquo;운영체제를 깨우는 알람 시계&rsquo; 같은 곳입니다. 컴퓨터가 켜지면 제일 먼저 이곳을 찾아 부팅에 필요한 파일을 읽습니다. 이 파티션을 <strong>FAT32 파일 시스템</strong>으로 포맷해야 했는데, 이건 UEFI 펌웨어라는 녀석이 이 형식만 읽을 수 있다고 명시했기 때문이었죠. 마치 통역사가 특정 언어만 알아듣는 것처럼요.</p><h4 id=swap-파티션><strong>Swap 파티션</strong><a hidden class=anchor aria-hidden=true href=#swap-파티션>#</a></h4><p>이건 &lsquo;RAM이 지칠 때 잠시 쉬어가는 임시 휴게소&rsquo;입니다. RAM(메모리)이 부족할 때 하드디스크의 이 공간을 빌려 쓴다는 걸 알았을 때, &lsquo;와, OS가 이렇게 똑똑하게 자원을 관리하는구나!&rsquo; 싶었습니다.</p><blockquote><p><em>처음에 Swap 파티션이 왜 필요하고, 어떻게 빌려쓰는 것인지 궁금해서 파고 또 파며 공부를 하다 보니, 가상 메모리, 페이징, MMU 학습까지 갔다가 돌아왔습니다. 🫠 덕분에 RAM의 실제 용량보다 더 많은 용량을 사용할 수 있는 시스템에 대해서 알게 되었습니다.(너무 깊게 가긴 했지만&mldr;)</em></p></blockquote><h4 id=root-파티션-ext4><strong>Root 파티션 (ext4)</strong><a hidden class=anchor aria-hidden=true href=#root-파티션-ext4>#</a></h4><p>이건 운영체제와 모든 파일이 들어가는 &lsquo;내 집&rsquo;의 가장 큰 방입니다. 리눅스에서는 ext4라는 파일 시스템을 주로 씁니다.</p><p>파티션 과정을 직접 겪으면서, 단순히 용량을 나누는 걸 넘어 데이터 저장 방식, 파일 시스템의 종류, 그리고 디스크 관리의 중요성을 몸으로 체감했습니다.</p><hr><h3 id=-하드웨어에-존재하는-운영체제-파일을-누가-실행시키는-걸까-펌웨어와-부트로드>🌐 하드웨어에 존재하는 운영체제 파일을 누가 실행시키는 걸까? (펌웨어와 부트로드)<a hidden class=anchor aria-hidden=true href=#-하드웨어에-존재하는-운영체제-파일을-누가-실행시키는-걸까-펌웨어와-부트로드>#</a></h3><p>파티션 과정을 넘겼더니 이제 부트로더와 펌웨어라는 녀석들이 등장했습니다. 공식 사이트 가이드에서 <code>grub-install</code> 같은 CLI 명령어를 입력하라고 하는데, 이 역할이 무엇인지부터 학습을 했습니다.</p><p>펌웨어는 하드웨어 장치에 내장된 아주 기본적인 지시사항이자, 하드웨어와 소프트웨어(운영체제)의 다리 역할을 합니다. 마치 &lsquo;하드웨어가 알아듣는 언어로 OS의 명령을 통역해주는 통역사&rsquo; 같은 거죠. 컴퓨터 전원을 켜면 가장 먼저 실행되는 것이 메인보드의 <strong>UEFI 펌웨어</strong>였습니다.</p><p>제가 아치 리눅스 설치할 때 EFI 시스템 파티션에 부트로더를 설치한 것도 바로 이 UEFI 펌웨어가 해당 부트로더를 찾아 실행할 수 있게 하기 위함이었습니다. 그리고 신기하게도 <code>grub-install</code> 명령어가 단순히 GRUB 파일을 복사하는 것을 넘어, UEFI 펌웨어 자체에 &ldquo;여기 아치 리눅스가 부팅할 파일이 있어!&ldquo;라고 알려주는 부팅 항목을 등록하는 역할까지 하는 것이죠.</p><blockquote><p><em>이 과정을 통해 하드웨어와 소프트웨어의 상호작용은 물론, 펌웨어의 역할, 그리고 시스템 부팅 시퀀스의 복잡성을 직접 경험하며 컴퓨터 시스템 아키텍처에 대한 깊은 이해를 얻게 됐습니다. 머릿속에 들어있던 컴퓨터 부팅 과정이 조금씩 구체화되었습니다.</em></p></blockquote><hr><h3 id=-네트워크와-원격-접속-ft-ssh와-no-route-to-host>🔗 네트워크와 원격 접속 (ft. <code>ssh</code>와 <code>No route to host</code>)<a hidden class=anchor aria-hidden=true href=#-네트워크와-원격-접속-ft-ssh와-no-route-to-host>#</a></h3><p>운영체제 설치를 마치고, 제 로컬 맥북에서 가상 머신에 접속하고 싶었습니다. 그러기 위해서는 <code>ssh</code>라는 것을 사용해야 했죠. 분명 GitHub에서 <code>repo</code>를 <code>clone</code>할 때 <code>ssh</code>라는 단어를 봤었는데, &lsquo;그게 그거인가?&rsquo; 하는 기억을 가지고 <code>ssh</code>가 무엇인지부터 학습했습니다. <code>ssh</code>는 원격으로 컴퓨터에 접속할 수 있는 프로토콜입니다. 이것을 통해 멀리 있는 컴퓨터에 여러 사람이 접속해서 마치 그 컴퓨터 앞에 앉아 사용하는 것처럼 할 수 있다는 점이 놀라웠습니다.</p><p>학습을 끝내고 가상 머신으로 띄운 제 아치 리눅스 컴퓨터에 로컬 터미널로 접속하기 위해 <code>ssh</code>를 사용해보기로 했습니다.</p><p>하지만 <code>ssh: connect to host 192.168.생략 port 22: No route to host</code>라는 에러가 발생했습니다.</p><p>에러 메시지를 확인해보니 제 맥북이 가상 환경의 SSH 서버에 접근하기 위한 **&lsquo;네트워크 상의 길 자체를 찾지 못했다&rsquo;**는 의미였습니다.</p><p>문제를 해결하기 위해 다음 과정을 차례로 시도해봤습니다.</p><ol><li>가상 머신이 켜져 있는지 확인.</li><li>가상 머신에 네트워크 연결이 되어 있는지 확인.</li><li>네트워크 IP 주소로 로컬에서 제대로 접속한 것인지 확인.</li><li>최후의 수단으로 가상 머신을 아예 재부팅해보기.</li></ol><p>1, 2, 3번 과정을 먼저 진행했으나 모두 정상임을 확인했습니다. 결국 최후의 수단인 재부팅을 하니 되는 것이 아니겠습니까&mldr;</p><p>알고 보니 재부팅 과정에서 가상 머신의 네트워크 인터페이스가 다시 깨끗하게 초기화되고, IP 주소를 올바르게 재할당받았으며, SSH 서버 데몬도 시스템 시작 시에 정상적으로 다시 실행되었던 겁니다.</p><p>최종적으로 아래처럼 로컬 터미널에서 Arch Linux로 접속에 성공했습니다.</p><p><strong><img alt="SSH 접속 성공 화면" loading=lazy src=/images/ssh-success.png title="SSH로 가상 머신에 접속한 모습"></strong></p><blockquote><p><em>이 단순한 &lsquo;재부팅 해결&rsquo;을 통해 네트워크 통신의 기본 원리, IP 주소 및 라우팅 개념, 그리고 운영체제 내에서 서비스 데몬이 어떻게 시작되고 동작하는지를 실전에서 이해하게 되었습니다. 눈에 보이지 않던 &lsquo;네트워크&rsquo;라는 길이 비로소 눈에 보이는 듯했습니다.</em></p></blockquote><hr><h3 id=-결론-삽질을-통한-성장>💡 결론: 삽질을 통한 성장<a hidden class=anchor aria-hidden=true href=#-결론-삽질을-통한-성장>#</a></h3><p>아치 리눅스 설치는 분명 쉽지 않았습니다. 얼마나 재설치를 많이 했는지&mldr; 하지만 이 &lsquo;삽질&rsquo;들은 제게 단순히 운영체제를 설치하는 방법을 넘어, 운영체제의 부팅 원리, 파일 시스템의 종류와 역할, 하드웨어와 소프트웨어의 상호작용, 그리고 기본적인 네트워크 통신 개념까지 CS의 핵심 기초 지식을 알게 되었습니다. 앞으로 더 많이, 더 깊게 알아야 된다는 것 또한 말이죠&mldr; 부지런히 공부해야겠습니다. 다행인 건 이런 공부가 재미있다는 것이 제겐 긍정적입니다.</p><p>비전공자였기에 오히려 더 깊이 파고들 수 있었던 것 같아요. 헤매긴 했으나, 그만큼 쌓이겠거니 생각합니다! 아무튼 아치 리눅스를 설치하면서 아무것도 몰랐던 컴퓨터 시스템을 직접 열어보고, 그 내부에서 어떤 일들이 벌어지는지 조금이나마 엿볼 수 있었던 소중한 경험이었습니다.</p><hr><p><strong>🔗 아치 리눅스 설치 과정 날것 기록 보러 가기: <a href="https://coconut-ferret-aac.notion.site/22902717a64780bf9e73ee71117f3013?source=copy_link">아치 리눅스 설치 및 학습 과정 노션 메모</a></strong></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://wan0514.github.io/tags/arch-linux/>Arch Linux</a></li><li><a href=https://wan0514.github.io/tags/cli/>CLI</a></li><li><a href=https://wan0514.github.io/tags/os/>OS</a></li><li><a href=https://wan0514.github.io/tags/utmvm/>UTM(VM)</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://wan0514.github.io/>wanja's blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>