<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>프로세스 메모리 구조 탐험기 | wanja's blog</title><meta name=keywords content="OS,Memory,Stack,Heap,Garbage Collection"><meta name=description content="CS 개념 학습 중 가장 추상적이고도 중요하다고 여겨지는 '프로세스 메모리 구조'를 직접 시뮬레이터를 구현하며 탐구한 여정을 담았습니다. 스택과 힙의 실제 작동 방식, malloc/free와 가비지 컬렉션의 미묘한 차이, 그리고 그 과정에서 겪었던 혼란과 깨달음을 솔직하게 풀어냈습니다."><meta name=author content="wanja"><link rel=canonical href=https://wan0514.github.io/posts/memory_model/><link crossorigin=anonymous href=/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css integrity="sha256-j+ECM6cGvIfy4Is8+XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as=style><link rel=icon href=https://wan0514.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://wan0514.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://wan0514.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://wan0514.github.io/apple-touch-icon.png><link rel=mask-icon href=https://wan0514.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://wan0514.github.io/posts/memory_model/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://wan0514.github.io/posts/memory_model/"><meta property="og:site_name" content="wanja's blog"><meta property="og:title" content="프로세스 메모리 구조 탐험기"><meta property="og:description" content="CS 개념 학습 중 가장 추상적이고도 중요하다고 여겨지는 '프로세스 메모리 구조'를 직접 시뮬레이터를 구현하며 탐구한 여정을 담았습니다. 스택과 힙의 실제 작동 방식, malloc/free와 가비지 컬렉션의 미묘한 차이, 그리고 그 과정에서 겪었던 혼란과 깨달음을 솔직하게 풀어냈습니다."><meta property="og:locale" content="ko"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-07-21T02:00:00+09:00"><meta property="article:modified_time" content="2025-07-21T02:00:00+09:00"><meta property="article:tag" content="OS"><meta property="article:tag" content="Memory"><meta property="article:tag" content="Stack"><meta property="article:tag" content="Heap"><meta property="article:tag" content="Garbage Collection"><meta name=twitter:card content="summary"><meta name=twitter:title content="프로세스 메모리 구조 탐험기"><meta name=twitter:description content="CS 개념 학습 중 가장 추상적이고도 중요하다고 여겨지는 '프로세스 메모리 구조'를 직접 시뮬레이터를 구현하며 탐구한 여정을 담았습니다. 스택과 힙의 실제 작동 방식, malloc/free와 가비지 컬렉션의 미묘한 차이, 그리고 그 과정에서 겪었던 혼란과 깨달음을 솔직하게 풀어냈습니다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://wan0514.github.io/posts/"},{"@type":"ListItem","position":2,"name":"프로세스 메모리 구조 탐험기","item":"https://wan0514.github.io/posts/memory_model/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"프로세스 메모리 구조 탐험기","name":"프로세스 메모리 구조 탐험기","description":"CS 개념 학습 중 가장 추상적이고도 중요하다고 여겨지는 '프로세스 메모리 구조'를 직접 시뮬레이터를 구현하며 탐구한 여정을 담았습니다. 스택과 힙의 실제 작동 방식, malloc/free와 가비지 컬렉션의 미묘한 차이, 그리고 그 과정에서 겪었던 혼란과 깨달음을 솔직하게 풀어냈습니다.","keywords":["OS","Memory","Stack","Heap","Garbage Collection"],"articleBody":"프로세스 메모리 구조 탐험기: 직접 만든 시뮬레이터와 함께한 탐구 스택과 힙 : 어떻게 메모리 안에서 서로 반대 방향에 있는 걸까? 처음 ‘스택과 힙이 서로 반대 방향으로 커진다’는 설명을 들었을 때, 추상적인 개념이라 잘 와닿지 않았습니다. 심지어는 개발 공부 초창기에는 메모리가 물리적으로 구역이 나뉘어 있다고 생각했습니다. 이번에 해당 개념을 깊게 학습하고 시뮬레이터를 구현하면서, 제가 얼마나 무지했는지를 깨달았습니다. 😂 애초에 메모리는 물리적인 주소값만 있으며, 그것을 논리적인 구역으로 나누고 관리하는 것은 운영체제의 내부 로직이 있기 때문이었습니다.\n제 시뮬레이터에서는 **baseAddress**를 기준으로 스택 영역은 높은 주소에서 낮은 주소로, 힙 영역은 메모리 낮은 주소에서 높은 주소로 커지게 설계했습니다.\n여기서 ‘반대 방향으로 커진다’는 의미는 스택은 메모리 상단(높은 주소)에서 아래로(낮은 주소로) 데이터를 쌓아가고, 힙은 메모리 하단(낮은 주소)에서 위로(높은 주소로) 데이터를 확장해나간다는 것을 뜻합니다.\n이렇게 두 영역이 서로의 경계를 향해 커져나가다가 결국 충돌하면 ‘스택 오버플로우’ 나 ‘힙 오버플로우’ 가 발생한다는 핵심 개념을 시각적으로 이해할 수 있었습니다. 이 충돌 지점을 효율적으로 관리하는 것이 메모리 관리의 중요한 부분이더군요.\n자바스크립트 함수 호출과 메모리: 지역 변수가 참조타입이면 어떻게 스텍에 쌓일까? 그동안 자바스크립트 개발하면서 ‘함수 호출하면 콜 스택에 쌓인다’는 것은 당연하게 생각했습니다. 하지만 내부적으로 어떻게 쌓이고, 함수의 지역 변수,매개변수, 타입(원시,참조)에 따른 저장방식 등에 대해서 알지 못했습니다. 그냥 ‘함수 실행 순서’ 정도만 알았던 거죠.\n이번 시뮬레이터를 만들면서 콜 스택 부분을 구현하고 학습하다 보니, 아, 이게 그냥 함수 이름만 쌓이는 게 아니었구나 꺠달았습니다. 함수가 호출되면 콜 스택에 해당 함수를 위한 ‘스택 프레임’ 이 만들어지는데, 그 안에는 다음과 같은 정보가 들어갑니다:\n함수 매개변수: 함수에 전달된 값 지역 변수: 함수 안에서 선언된 변수 반환 주소: 함수 실행이 끝나면 어디로 돌아가야 하는지 알려주는 이정표 이 모든 정보들이 차곡차곡 스택에 쌓이고, 함수 실행이 끝나면 이 ‘스택 프레임’이 통째로 사라지며, LIFO(Last-In, First-Out) 구조라는 걸 직접 구현하면서 체감할 수 있었습니다. ‘아, 그래서 함수 호출이 많으면 스택 오버플로우가 나는 거구나!’ 싶었습니다.\n공부하면서 가장 기억에 남는 것 중 하나는 바로 참조 타입(객체, 배열 등)의 저장 방식이었습니다. 원래 참조타입은 heap에 저장이 되고, heap 주소값이 변수에 담긴다는 것은 머리로 알고 있었으나 함수 프레임에 지역변수에 해당 포인터 변수가 스텍으로 쌓인다는 것까지 생각하진 못했거든요.\n실제 데이터는 힙으로: 자바스크립트에서 {} 객체나 [] 배열처럼 크기가 가변적이거나 함수 종료 후에도 유지될 필요가 있는 참조 타입 데이터는 콜 스택이 아닌 ‘힙(Heap)’ 메모리 영역에 저장된다는 걸 알게 됐습니다. 힙은 스택처럼 깔끔하게 LIFO로 관리되는 게 아니라, 필요한 만큼 썼다 지웠다 할 수 있는 자유로운 공간입니다. 스택에 남는 건 ‘주소’: 그럼 스택에는 뭐가 남을까요? 바로 힙에 저장된 그 객체나 배열의 **‘시작 주소(포인터)’**만 남는다는 사실입니다. 마치 스택에 “내용은 힙의 저~~기 0x1234번지에 있어!“라는 메모만 적혀있는 것과 같습니다. 이 개념을 알고 나니 모든 퍼즐 조각이 맞춰졌습니다. 함수가 반환되어 스택에서 사라질 때, 해당 함수의 스택 프레임과 그 안에 있던 지역 변수(원시 값, 그리고 힙 데이터의 주소값)는 없어집니다. 하지만 힙에 저장되어 있던 실제 객체나 배열 데이터는 그대로 남아있다는 것이죠! 이걸 몰랐다니… 정말 CS 개념을 제대로 알아야 하는 이유를 뼈저리게 느꼈습니다. 힙에 남은 데이터는 나중에 가비지 컬렉터가 알아서 정리해 줄 때까지 존재하게 됩니다.\n번외 : 클로저(Closure)는 어디에 저장될까? 메모리 구조를 공부하다 보니, 함수가 종료되었는데도 외부 변수에 접근할 수 있는 **클로저(Closure)**의 동작 원리가 궁금해졌습니다. 클로저가 외부 스코프의 변수를 기억하고 접근할 수 있는 이유는, 자바스크립트 엔진이 해당 변수들을 힙(Heap) 메모리에 저장하기 때문입니다. 함수 실행이 끝나 스택에서 사라진 후에도, 엔진은 그 변수들이 클로저에 의해 여전히 참조되고 있음을 파악합니다. 따라서 클로저가 유효한 동안에는 해당 변수들을 힙에서 회수하지 않고 유지하며, 이 모든 과정은 엔진이 렉시컬 환경을 분석하여 자동으로 수행합니다.\nmalloc 시뮬레이터로 이 흐름을 구현하다 이러한 스택과 힙의 상호작용을 제 시뮬레이터의 malloc 함수로 구현하면서 정말 많은 것을 배웠습니다. 저는 메모리 모델의 복잡한 전체 구조를 완벽하게 시뮬레이터로 구현하기보다는, 함수 호출 시 스택에 쌓이는 과정과 함수 내부의 참조 타입 변수가 힙에 저장되고 그 포인터 주소가 스택의 함수 프레임에 쌓이는 과정에 집중했습니다.\n제 malloc 함수는 이렇게 작동했습니다:\n힙에 공간 확보: 먼저 요청받은 타입과 개수만큼의 메모리를 힙 영역(Map으로 추상화된 this.heap)에 실제로 할당하고 그 정보를 기록합니다. 여기까지는 실제 malloc과 동일한 역할이죠. 스택에 ‘힙 포인터’ 기록: 그리고 나서, 힙에 할당된 그 메모리의 주소(힙 주소)를 담을 4바이트짜리 ‘포인터 변수 공간’을 스택 영역(this.stack 배열)에 할당합니다. 스택 주소 반환: 최종적으로, malloc 함수는 힙 주소를 직접 반환하는 대신, 스택에 생성된 그 ‘포인터 변수’의 주소를 반환합니다. 이 구현 방식을 통해, 저는 ‘함수 내부의 지역 포인터 변수(스택)가 힙에 있는 실제 데이터를 가리키는’ C 언어의 핵심적인 메모리 흐름을 직접 모방하고 학습할 수 있었습니다. 코드를 통해 눈에 보이지 않던 메모리의 움직임을 구현해보니, 비로소 스택과 힙, 그리고 포인터의 관계가 머릿속에 확실히 자리 잡게 되었습니다.\nfree()와 가비지 컬렉터, 같아 보였지만 달랐던 역할 free()와 가비지 컬렉터(GC) 모두 ‘사용되지 않는 메모리를 해제한다’는 점에서 비슷하다고 막연히 생각했습니다. 그러다 보니 시뮬레이터를 구현하면서 free와 가비지 컬렉터를 구현할 때 혼란이 왔었습니다. 둘 다 heap 메모리를 해제하는 역할은 같은데, 무슨 차이가 있는 걸까…? 생각하며 학습을 진행했습니다.\n이 둘은 메모리 해제 주체와 방식에서 결정적인 차이가 있었습니다.\nfree(): 이는 개발자가 명시적으로 ‘이 메모리는 이제 필요 없으니 재사용하시오!‘라고 시스템에 직접 명령하는 것입니다. 마치 책임을 다한 작업자가 ‘제 일은 여기서 끝입니다!’ 하고 자리를 비우는 것과 같습니다. 따라서 해당 메모리가 다른 곳에서 여전히 참조되고 있는지 여부는 free()가 신경 쓰지 않습니다. 이 때문에 만약 다른 곳에서 아직 참조하고 있는 메모리를 free()하면 Use-After-Free(UAF) 버그와 같은 치명적인 문제가 발생할 수 있다는 것을 배웠습니다. 이는 프로그램 충돌, 데이터 손상, 심지어 보안 취약점으로 이어질 수 있는 무서운 오류입니다.\n가비지 컬렉터 (GC): GC는 프로그래머의 개입 없이 런타임 환경이 스스로 메모리 사용 현황을 ‘감시’하고 ‘판단’하여 작동합니다. 마치 뒤에서 조용히 청소하는 관리자처럼, ‘더 이상 어떤 코드에서도 접근할 수 없는’ 메모리 블록들을 찾아 자동으로 해제합니다. 이 과정에서 개발자는 메모리 해제 시점을 걱정할 필요가 없어져 생산성과 프로그램 안정성이 높아집니다.\n결국, 둘 다 힙 메모리를 ‘재사용 가능한 상태’로 만든다는 목표는 같지만, free는 개발자의 ‘수동적이고 즉각적인 지시’ 인 반면, GC는 런타임의 ‘자동적이고 지능적인 판단’ 이라는 근본적인 차이가 있었습니다. 이 차이를 명확히 이해하게 된 것이 이번 학습의 큰 의미 중 하나였습니다.\n만약 제가 c언어를 알았다면 malloc과 free를 사용해보았으면 좋았을 텐데 하는 생각을 했습니다. 다음에 cs 스터디를 한다면 c언어와 함께 공부를 해보겠다는 목표가 세워봅니다…\n힙 메모리 관리를 어떻게 해야할까? : Free List라는 존재의 필요성 힙 메모리 관리는 스택과 달리 훨씬 복잡했습니다. 스택은 LIFO 구조라 스택 포인터(Stack Pointer) 하나로 다음 위치를 쉽게 알 수 있지만, 힙은 임의의 크기, 임의의 순서로 할당/해제되니 메모리 단편화가 발생할 수밖에 없죠.\n처음에는 이 힙 관리를 어떻게 시뮬레이션할지 고민이 많았습니다. 단순히 heapPointer 하나로 스택처럼 다음 할당될 위치를 관리하는 방식은 구현은 간단하겠지만, 실제 힙의 유동적인 특성을 제대로 반영하지 못할 것 같았습니다. 그렇다고 힙을 객체들의 집합으로만 두고, 각 객체에 메타데이터(크기, 할당 여부 불린 값 등)를 포함시켜 free나 GC 시마다 힙 전체를 순회하며 해제된 블록을 찾아내는 방식은 너무 번거롭고 비효율적이라고 생각했습니다.\n여기서 바로 ‘Free List’ 이라는 개념을 접하게 되었고, 눈이 번쩍 뜨였습니다.😮 Free List은 해제된 메모리 블록들을 효율적으로 관리하는 자료구조였습니다. 이 개념을 알게 되니, 앞서 고민했던 번거로운 힙 순회 없이도 해제된 메모리를 빠르게 찾아 재사용할 수 있는 방법이 있다는 것을 알게 되었습니다.\n더 나아가, Free List 안에서도 First-Fit, Best-Fit과 같은 다양한 할당 알고리즘이 존재하며, 심지어 실제 시스템에서는 할당될 크기에 따라 여러 개의 Free List을 두어 특정 크기에 맞는 빈 공간을 더 빠르게 찾는 방식도 있다는 것을 학습했습니다. (예: 8바이트용 Free List, 16바이트용 Free List 등).\n제 시뮬레이터에서는 지금 당장 이 모든 복잡한 알고리즘과 여러 Free List을 구현하지는 않았지만, 이러한 개념들이 ‘힙 포인터’ 하나로는 설명될 수 없는 힙 관리의 실제 복잡성과 그를 해결하기 위한 효율적인 방식들이라는 것을 이해하게 되었습니다.\n마무리하며: 코드로 탐험하는 CS의 즐거움 이번 프로세스 메모리 시뮬레이터 구현은 단순히 글과 그림으로만 접했던 스택, 힙, 포인터, 그리고 메모리 관리자들의 역할을 직접 코드를 짜고 동작을 시켜보면서 이해하는 경험을 주었습니다.\n특히, 제가 겪었던 혼란스러운 지점들을 하나하나 파헤치고 납득하는 과정 자체가 가장 큰 공부였습니다. malloc의 반환 값, free와 GC의 미묘한 차이, 그리고 힙 포인터의 의미 등. 머릿속으로만 알던 지식이 직접 구현하고 설계하는 과정을 거쳐 제것이 되는 과정이었습니다.\n","wordCount":"1194","inLanguage":"en","datePublished":"2025-07-21T02:00:00+09:00","dateModified":"2025-07-21T02:00:00+09:00","author":{"@type":"Person","name":"wanja"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://wan0514.github.io/posts/memory_model/"},"publisher":{"@type":"Organization","name":"wanja's blog","logo":{"@type":"ImageObject","url":"https://wan0514.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://wan0514.github.io/ accesskey=h title="wanja's blog (Alt + H)">wanja's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">프로세스 메모리 구조 탐험기</h1><div class=post-description>CS 개념 학습 중 가장 추상적이고도 중요하다고 여겨지는 '프로세스 메모리 구조'를 직접 시뮬레이터를 구현하며 탐구한 여정을 담았습니다. 스택과 힙의 실제 작동 방식, malloc/free와 가비지 컬렉션의 미묘한 차이, 그리고 그 과정에서 겪었던 혼란과 깨달음을 솔직하게 풀어냈습니다.</div><div class=post-meta><span title='2025-07-21 02:00:00 +0900 +0900'>July 21, 2025</span>&nbsp;·&nbsp;wanja</div></header><div class=post-content><h2 id=프로세스-메모리-구조-탐험기-직접-만든-시뮬레이터와-함께한-탐구>프로세스 메모리 구조 탐험기: 직접 만든 시뮬레이터와 함께한 탐구<a hidden class=anchor aria-hidden=true href=#프로세스-메모리-구조-탐험기-직접-만든-시뮬레이터와-함께한-탐구>#</a></h2><h3 id=스택과-힙--어떻게-메모리-안에서-서로-반대-방향에-있는-걸까>스택과 힙 : 어떻게 메모리 안에서 서로 반대 방향에 있는 걸까?<a hidden class=anchor aria-hidden=true href=#스택과-힙--어떻게-메모리-안에서-서로-반대-방향에-있는-걸까>#</a></h3><p>처음 &lsquo;스택과 힙이 서로 반대 방향으로 커진다&rsquo;는 설명을 들었을 때, 추상적인 개념이라 잘 와닿지 않았습니다. 심지어는 개발 공부 초창기에는 메모리가 물리적으로 구역이 나뉘어 있다고 생각했습니다. 이번에 해당 개념을 깊게 학습하고 시뮬레이터를 구현하면서, 제가 얼마나 무지했는지를 깨달았습니다. 😂 애초에 메모리는 물리적인 주소값만 있으며, 그것을 논리적인 구역으로 나누고 관리하는 것은 운영체제의 내부 로직이 있기 때문이었습니다.</p><p>제 시뮬레이터에서는 **<code>baseAddress</code>**를 기준으로 스택 영역은 높은 주소에서 낮은 주소로, 힙 영역은 메모리 낮은 주소에서 높은 주소로 커지게 설계했습니다.</p><p>여기서 <strong>&lsquo;반대 방향으로 커진다&rsquo;는 의미는 스택은 메모리 상단(높은 주소)에서 아래로(낮은 주소로) 데이터를 쌓아가고, 힙은 메모리 하단(낮은 주소)에서 위로(높은 주소로) 데이터를 확장해나간다</strong>는 것을 뜻합니다.</p><p>이렇게 두 영역이 서로의 경계를 향해 커져나가다가 결국 충돌하면 <strong>&lsquo;스택 오버플로우&rsquo;</strong> 나 <strong>&lsquo;힙 오버플로우&rsquo;</strong> 가 발생한다는 핵심 개념을 시각적으로 이해할 수 있었습니다. 이 충돌 지점을 효율적으로 관리하는 것이 메모리 관리의 중요한 부분이더군요.</p><hr><h3 id=자바스크립트-함수-호출과-메모리-지역-변수가-참조타입이면-어떻게-스텍에-쌓일까>자바스크립트 함수 호출과 메모리: 지역 변수가 참조타입이면 어떻게 스텍에 쌓일까?<a hidden class=anchor aria-hidden=true href=#자바스크립트-함수-호출과-메모리-지역-변수가-참조타입이면-어떻게-스텍에-쌓일까>#</a></h3><p>그동안 자바스크립트 개발하면서 &lsquo;함수 호출하면 콜 스택에 쌓인다&rsquo;는 것은 당연하게 생각했습니다. 하지만 내부적으로 어떻게 쌓이고, 함수의 지역 변수,매개변수, 타입(원시,참조)에 따른 저장방식 등에 대해서 알지 못했습니다. 그냥 &lsquo;함수 실행 순서&rsquo; 정도만 알았던 거죠.</p><p>이번 시뮬레이터를 만들면서 콜 스택 부분을 구현하고 학습하다 보니, 아, 이게 그냥 함수 이름만 쌓이는 게 아니었구나 꺠달았습니다. 함수가 호출되면 콜 스택에 해당 함수를 위한 <strong>&lsquo;스택 프레임&rsquo;</strong> 이 만들어지는데, 그 안에는 다음과 같은 정보가 들어갑니다:</p><ul><li><strong>함수 매개변수</strong>: 함수에 전달된 값</li><li><strong>지역 변수</strong>: 함수 안에서 선언된 변수</li><li><strong>반환 주소</strong>: 함수 실행이 끝나면 어디로 돌아가야 하는지 알려주는 이정표</li></ul><p>이 모든 정보들이 차곡차곡 스택에 쌓이고, 함수 실행이 끝나면 이 &lsquo;스택 프레임&rsquo;이 통째로 사라지며, <strong>LIFO(Last-In, First-Out)</strong> 구조라는 걸 직접 구현하면서 체감할 수 있었습니다. &lsquo;아, 그래서 함수 호출이 많으면 스택 오버플로우가 나는 거구나!&rsquo; 싶었습니다.</p><p>공부하면서 가장 기억에 남는 것 중 하나는 바로 <strong>참조 타입(객체, 배열 등)의 저장 방식</strong>이었습니다. 원래 참조타입은 heap에 저장이 되고, heap 주소값이 변수에 담긴다는 것은 머리로 알고 있었으나 함수 프레임에 지역변수에 해당 포인터 변수가 스텍으로 쌓인다는 것까지 생각하진 못했거든요.</p><ul><li><strong>실제 데이터는 힙으로</strong>: 자바스크립트에서 <code>{}</code> 객체나 <code>[]</code> 배열처럼 크기가 가변적이거나 함수 종료 후에도 유지될 필요가 있는 <strong>참조 타입 데이터는 콜 스택이 아닌 &lsquo;힙(Heap)&rsquo; 메모리 영역에 저장</strong>된다는 걸 알게 됐습니다. 힙은 스택처럼 깔끔하게 LIFO로 관리되는 게 아니라, 필요한 만큼 썼다 지웠다 할 수 있는 자유로운 공간입니다.</li><li><strong>스택에 남는 건 &lsquo;주소&rsquo;</strong>: 그럼 스택에는 뭐가 남을까요? 바로 힙에 저장된 그 객체나 배열의 **&lsquo;시작 주소(포인터)&rsquo;**만 남는다는 사실입니다. 마치 스택에 &ldquo;내용은 힙의 저~~기 0x1234번지에 있어!&ldquo;라는 메모만 적혀있는 것과 같습니다.</li></ul><p>이 개념을 알고 나니 모든 퍼즐 조각이 맞춰졌습니다. 함수가 반환되어 스택에서 사라질 때, 해당 함수의 스택 프레임과 그 안에 있던 지역 변수(원시 값, <strong>그리고 힙 데이터의 주소값</strong>)는 없어집니다. 하지만 <strong>힙에 저장되어 있던 실제 객체나 배열 데이터는 그대로 남아있다</strong>는 것이죠! 이걸 몰랐다니&mldr; 정말 CS 개념을 제대로 알아야 하는 이유를 뼈저리게 느꼈습니다. 힙에 남은 데이터는 나중에 <strong>가비지 컬렉터</strong>가 알아서 정리해 줄 때까지 존재하게 됩니다.</p><blockquote><h4 id=번외--클로저closure는-어디에-저장될까>번외 : 클로저(Closure)는 어디에 저장될까?<a hidden class=anchor aria-hidden=true href=#번외--클로저closure는-어디에-저장될까>#</a></h4><p>메모리 구조를 공부하다 보니, 함수가 종료되었는데도 외부 변수에 접근할 수 있는 **클로저(Closure)**의 동작 원리가 궁금해졌습니다. 클로저가 외부 스코프의 변수를 기억하고 접근할 수 있는 이유는, 자바스크립트 엔진이 해당 변수들을 힙(Heap) 메모리에 저장하기 때문입니다. 함수 실행이 끝나 스택에서 사라진 후에도, 엔진은 그 변수들이 클로저에 의해 여전히 참조되고 있음을 파악합니다. 따라서 클로저가 유효한 동안에는 해당 변수들을 힙에서 회수하지 않고 유지하며, 이 모든 과정은 엔진이 렉시컬 환경을 분석하여 자동으로 수행합니다.</p></blockquote><hr><h3 id=malloc-시뮬레이터로-이-흐름을-구현하다><code>malloc</code> 시뮬레이터로 이 흐름을 구현하다<a hidden class=anchor aria-hidden=true href=#malloc-시뮬레이터로-이-흐름을-구현하다>#</a></h3><p>이러한 스택과 힙의 상호작용을 제 시뮬레이터의 <code>malloc</code> 함수로 구현하면서 정말 많은 것을 배웠습니다.
저는 메모리 모델의 복잡한 전체 구조를 완벽하게 시뮬레이터로 구현하기보다는, 함수 호출 시 스택에 쌓이는 과정과 함수 내부의 참조 타입 변수가 힙에 저장되고 그 포인터 주소가 스택의 함수 프레임에 쌓이는 과정에 집중했습니다.</p><p>제 <code>malloc</code> 함수는 이렇게 작동했습니다:</p><ol><li><strong>힙에 공간 확보</strong>: 먼저 요청받은 타입과 개수만큼의 메모리를 <strong>힙 영역(Map으로 추상화된 <code>this.heap</code>)에 실제로 할당</strong>하고 그 정보를 기록합니다. 여기까지는 실제 <code>malloc</code>과 동일한 역할이죠.</li><li><strong>스택에 &lsquo;힙 포인터&rsquo; 기록</strong>: 그리고 나서, 힙에 할당된 그 <strong>메모리의 주소(힙 주소)를 담을 4바이트짜리 &lsquo;포인터 변수 공간&rsquo;을 스택 영역(<code>this.stack</code> 배열)에 할당</strong>합니다.</li><li><strong>스택 주소 반환</strong>: 최종적으로, <code>malloc</code> 함수는 힙 주소를 직접 반환하는 대신, <strong>스택에 생성된 그 &lsquo;포인터 변수&rsquo;의 주소를 반환</strong>합니다.</li></ol><p>이 구현 방식을 통해, 저는 <strong>&lsquo;함수 내부의 지역 포인터 변수(스택)가 힙에 있는 실제 데이터를 가리키는&rsquo;</strong> C 언어의 핵심적인 메모리 흐름을 직접 모방하고 학습할 수 있었습니다. 코드를 통해 눈에 보이지 않던 메모리의 움직임을 구현해보니, 비로소 스택과 힙, 그리고 포인터의 관계가 머릿속에 확실히 자리 잡게 되었습니다.</p><hr><h3 id=free와-가비지-컬렉터-같아-보였지만-달랐던-역할><code>free()</code>와 가비지 컬렉터, 같아 보였지만 달랐던 역할<a hidden class=anchor aria-hidden=true href=#free와-가비지-컬렉터-같아-보였지만-달랐던-역할>#</a></h3><p><code>free()</code>와 가비지 컬렉터(GC) 모두 &lsquo;사용되지 않는 메모리를 해제한다&rsquo;는 점에서 비슷하다고 막연히 생각했습니다. 그러다 보니 시뮬레이터를 구현하면서 free와 가비지 컬렉터를 구현할 때 혼란이 왔었습니다. 둘 다 heap 메모리를 해제하는 역할은 같은데, 무슨 차이가 있는 걸까&mldr;? 생각하며 학습을 진행했습니다.</p><p>이 둘은 <strong>메모리 해제 주체</strong>와 <strong>방식</strong>에서 결정적인 차이가 있었습니다.</p><ul><li><p><strong><code>free()</code></strong>: 이는 개발자가 <strong>명시적으로 &lsquo;이 메모리는 이제 필요 없으니 재사용하시오!&lsquo;라고 시스템에 직접 명령</strong>하는 것입니다. 마치 책임을 다한 작업자가 &lsquo;제 일은 여기서 끝입니다!&rsquo; 하고 자리를 비우는 것과 같습니다. 따라서 해당 메모리가 다른 곳에서 여전히 참조되고 있는지 여부는 <code>free()</code>가 신경 쓰지 않습니다. 이 때문에 만약 다른 곳에서 아직 참조하고 있는 메모리를 <code>free()</code>하면 <strong>Use-After-Free(UAF) 버그</strong>와 같은 치명적인 문제가 발생할 수 있다는 것을 배웠습니다. 이는 프로그램 충돌, 데이터 손상, 심지어 보안 취약점으로 이어질 수 있는 무서운 오류입니다.</p></li><li><p><strong>가비지 컬렉터 (GC)</strong>: GC는 프로그래머의 개입 없이 <strong>런타임 환경이 스스로 메모리 사용 현황을 &lsquo;감시&rsquo;하고 &lsquo;판단&rsquo;하여</strong> 작동합니다. 마치 뒤에서 조용히 청소하는 관리자처럼, <strong>&lsquo;더 이상 어떤 코드에서도 접근할 수 없는&rsquo; 메모리 블록들을 찾아 자동으로 해제</strong>합니다. 이 과정에서 개발자는 메모리 해제 시점을 걱정할 필요가 없어져 생산성과 프로그램 안정성이 높아집니다.</p></li></ul><p>결국, 둘 다 힙 메모리를 &lsquo;재사용 가능한 상태&rsquo;로 만든다는 목표는 같지만, <code>free</code>는 개발자의 <strong>&lsquo;수동적이고 즉각적인 지시&rsquo;</strong> 인 반면, GC는 런타임의 <strong>&lsquo;자동적이고 지능적인 판단&rsquo;</strong> 이라는 근본적인 차이가 있었습니다. 이 차이를 명확히 이해하게 된 것이 이번 학습의 큰 의미 중 하나였습니다.</p><blockquote><p>만약 제가 c언어를 알았다면 malloc과 free를 사용해보았으면 좋았을 텐데 하는 생각을 했습니다. 다음에 cs 스터디를 한다면 c언어와 함께 공부를 해보겠다는 목표가 세워봅니다&mldr;</p></blockquote><hr><h3 id=힙-메모리-관리를-어떻게-해야할까--free-list라는-존재의-필요성>힙 메모리 관리를 어떻게 해야할까? : Free List라는 존재의 필요성<a hidden class=anchor aria-hidden=true href=#힙-메모리-관리를-어떻게-해야할까--free-list라는-존재의-필요성>#</a></h3><p>힙 메모리 관리는 스택과 달리 훨씬 복잡했습니다. 스택은 LIFO 구조라 <strong>스택 포인터(Stack Pointer)</strong> 하나로 다음 위치를 쉽게 알 수 있지만, 힙은 임의의 크기, 임의의 순서로 할당/해제되니 <strong>메모리 단편화</strong>가 발생할 수밖에 없죠.</p><p>처음에는 이 힙 관리를 어떻게 시뮬레이션할지 고민이 많았습니다. 단순히 <strong><code>heapPointer</code> 하나로 스택처럼 다음 할당될 위치를 관리</strong>하는 방식은 구현은 간단하겠지만, 실제 힙의 유동적인 특성을 제대로 반영하지 못할 것 같았습니다. 그렇다고 힙을 객체들의 집합으로만 두고, 각 객체에 <strong>메타데이터(크기, 할당 여부 불린 값 등)를 포함시켜 <code>free</code>나 GC 시마다 힙 전체를 순회하며 해제된 블록을 찾아내는 방식</strong>은 너무 번거롭고 비효율적이라고 생각했습니다.</p><p>여기서 바로 <strong>&lsquo;Free List&rsquo;</strong> 이라는 개념을 접하게 되었고, 눈이 번쩍 뜨였습니다.😮 Free List은 해제된 메모리 블록들을 효율적으로 관리하는 자료구조였습니다. 이 개념을 알게 되니, 앞서 고민했던 <strong>번거로운 힙 순회 없이도 해제된 메모리를 빠르게 찾아 재사용할 수 있는 방법</strong>이 있다는 것을 알게 되었습니다.</p><p>더 나아가, Free List 안에서도 <strong>First-Fit, Best-Fit</strong>과 같은 다양한 할당 알고리즘이 존재하며, 심지어 실제 시스템에서는 할당될 크기에 따라 <strong>여러 개의 Free List을 두어 특정 크기에 맞는 빈 공간을 더 빠르게 찾는 방식</strong>도 있다는 것을 학습했습니다. (예: 8바이트용 Free List, 16바이트용 Free List 등).</p><p>제 시뮬레이터에서는 지금 당장 이 모든 복잡한 알고리즘과 여러 Free List을 구현하지는 않았지만, 이러한 개념들이 &lsquo;힙 포인터&rsquo; 하나로는 설명될 수 없는 힙 관리의 실제 복잡성과 그를 해결하기 위한 효율적인 방식들이라는 것을 이해하게 되었습니다.</p><hr><h2 id=마무리하며-코드로-탐험하는-cs의-즐거움>마무리하며: 코드로 탐험하는 CS의 즐거움<a hidden class=anchor aria-hidden=true href=#마무리하며-코드로-탐험하는-cs의-즐거움>#</a></h2><p>이번 프로세스 메모리 시뮬레이터 구현은 단순히 글과 그림으로만 접했던 스택, 힙, 포인터, 그리고 메모리 관리자들의 역할을 <strong>직접 코드를 짜고 동작을 시켜보면서</strong> 이해하는 경험을 주었습니다.</p><p>특히, 제가 겪었던 혼란스러운 지점들을 하나하나 파헤치고 납득하는 과정 자체가 가장 큰 공부였습니다. <code>malloc</code>의 반환 값, <code>free</code>와 GC의 미묘한 차이, 그리고 힙 포인터의 의미 등. 머릿속으로만 알던 지식이 직접 구현하고 설계하는 과정을 거쳐 제것이 되는 과정이었습니다.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://wan0514.github.io/tags/os/>OS</a></li><li><a href=https://wan0514.github.io/tags/memory/>Memory</a></li><li><a href=https://wan0514.github.io/tags/stack/>Stack</a></li><li><a href=https://wan0514.github.io/tags/heap/>Heap</a></li><li><a href=https://wan0514.github.io/tags/garbage-collection/>Garbage Collection</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://wan0514.github.io/>wanja's blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>